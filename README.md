# Скрипты для планировщика

## Что это?

В этом проекте находятся:
- тесты на входные и выходные данные планировщика.
- скрипт для создания входного файла с данными по модельному сценарию (Войтенко П.Е.).
- скрипт для составления отчетов по взаимодействию с УТХ.
- черновой блокнот с идеями по усовершенствованию алгоритмов планирования.
- разные вспомогательные скрипты.

Все оформлено в виде блокнотов (notebooks) для Jupyter, код написан на Python 3.5. Для работы нужны библиотеки `pandas, numpy, scipy, matplotlib, seaborn, networkx, literal_eval, os, zip, datetime` (возможно, что-то забыл - смотрите `import`'ы в начале блокнотов). Многие из этих пакетов есть в сборке Anaconda (см. ниже), недостающие можно доставить командой `conda %package_name% install -f`.

### Как смотреть блокноты

1. Можно установить себе [Anaconda](https://www.continuum.io/downloads), запустить Jupyter Notebook (можно из командной строки: `jupyter notebook`). Затем сделать форк проекта и смотреть и запускать блокноты прямо из браузера, открывая нужные файлы у себя на компьютере. Редактировать блокноты - там же.
2. Можно смотреть из гитхаба. Известный подводный камень: в движке гитхаба есть баг (похоже, просто старая версия обработчика блокнотов), из-за которого есть косяки в отображении LaTeX-формул.
3. Можно смотреть из [NBViewer](http://nbviewer.jupyter.org/). Можно в поле на главной странице вьювера скопировать прямую ссылку на блокнот на гитхабе, а можно вбить только ник пользователя - появится простой файловый менеджер, в нем найти и открыть нужный блокнот.

Пункты 2 и 3, разумеется, позволяют только смотреть блокноты, но не редактировать.

## Тесты

### Список тестов

Все тесты представлены в нескольких блокнотах. Каждый блокнот нацелен на создание одного html-файла с отчетом. Также есть вспомогательные скрипты: подготовка py-файлов к автономной работе и батник для запуска всего зоопарка скриптов.

Имеющиеся блокноты:
1.  **Read.ipynb.** Здесь происходит парсинг лога планировщика. Имя файла с логами задается в начале скрипта в переменной `file_name` (по умолчанию лог берется из `./input/jason-FullPlannerPlugin.log`, если запускать скрипт из командной строки с ключом `log_for`, то лог будет браться из `./input/log_for_analysis.log`). Этот скрипт надо всегда запускать перед началом анализа очередного запуска планировщика. По завершении работы скрипт создаст в папке `./resources` пачку csv-файлов, название каждого файла будет соответствовать префиксу входного или выходного сообщения для планировщика. В каждом созданном csv-файле будут лежать соответствующие данные в удобной табличной форме.
2. **_input_report.ipynb**. Здесь собраны тесты на корректность и полноту входных данных. Описание всех тестов приведено в самом блокноте, а также в документе "Автоматические тесты.docx".
3. **_train_report.ipynb**. Здесь собраны тесты на результаты планирования в части поездов. Проверяются правильность нумерации поездов, корректность времен стоянок для смены локомотивов и бригад, случаи отправки поездов в очень близкое время, сравнение запланированного количества поездов с данными АС ССП (по всем станциям и отдельно детально - по Иркутску), корректность планирования сдвоенных поездов. Описание всех тестов приведено в самом блокноте.
4. **_loco_report.ipynb**. Здесь собраны тесты на результаты планирования по локомотивам. Проверяются невыезды локомотивов за пределы тяговых плеч, корректность выбора станций проведения ТО, количество отправлений локомотивов резервом, станции смены локомотивов, скачки по времени в локомотивных планах. Описание всех тестов приведено в самом блокноте.
5. **_team_report.ipynb**. Здесь собраны тесты на результаты планирования по бригадам. Проверяются проценты подвязки (в том числе, какой процент от реальных бригад был использован в планировании), участки, на которых не состоялась подвязка, переработка бригад, недостаточный отдых бригад, смена бригад на корректных станциях, ненарушение ограничений на время явки (для не-УТХ-бригад и для бригад, запланированных на предыдущем расчете) и пр. Описание всех тестов приведено в самом блокноте.
6. **_task_report.ipynb**. Описание всех тестов приведено в самом блокноте.
7. **_slot_report.ipynb**. Описание всех тестов приведено в самом блокноте.

### Как работать с тестами

1. Для работы в папке с тестовыми скриптами должны быть созданы подпапки `input`, `resources`, `report`:
  1. В папку input требуется поместить файл с логами для анализа.
  2. В папке `resources` должна присутствовать папка `mandatory` (ее можно скопировать из этого проекта). В ней находятся разные вспомогательные вещи (вроде списка названий серий локомотивов, приоритетных стацний смены локомотивов и бригад и пр.), которые нужны для работы некоторых тестов.
  3. В папке `report` будут созданы html-файлы с отчетами.
2. Для запуска теста достаточно открыть его в Jupyter Notebook и сделать Cell - Run All. Нужный отчет появится в папке `report` (время создания зависит от отчета - от 5 до 25 секунд).
3. Метод из п.2 достаточно долгий и требует многих действий: запуска Jupyter, открытия блокнота. Можно сделать быстрее. Можно сохранить файл блокнота как скрипт с расширением *.py и затем запускать нужный файл из командой строки командой `python %filename%.py`. Здесь же лежит батник `create_reports.bat`, который генерирует все отчеты.
  1. Важный нюанс. В блокнотах иногда используются magic-команды для удобства отображения результатов (самое распространенное - команда `%matplotlib inline%` для отображения построенных графиков прямо в самом блокноте). При попытке исполнения скрипта из командой строки питон не сможет воспроизвести эти команды. Поэтому перед запуском надо прогнать батник `release.bat`, который почистит py-файлы (уберет magic-команды, проставит переменной PRINT значение False, чтобы результаты тестов не засоряли консоль). Запуск `release.bat` включен в `create_reports.bat`.
  2. Можно настроить Jupyter так, чтобы py-файл автоматически создавался при сохранении блокнота. Для этого найти папку `.jupyter`, в ней в файл `jupyter_notebook_config.py` добавить строки: 
  
```  
  import os  
  from subprocess import check_call  
  def post_save(model, os_path, contents_manager):      
    if model['type'] != 'notebook':
        return # only do this for notebooks
    d, fname = os.path.split(os_path)
    check_call(['jupyter', 'nbconvert', '--to', 'script', fname], cwd=d)
    #check_call(['jupyter', 'nbconvert', '--to', 'html', fname], cwd=d)

  c.FileContentsManager.post_save_hook = post_save
```

Подробнее можно посмотреть [здесь](https://github.com/ipython/ipython/issues/8009).

## Создание входного файла для модельного сценария

1. Для этого используется блокнот `make_test_scenario.ipynb`.
2. Все нужные данные должны находиться где-то рядом с файлом блокнота. Детальное описание требуемых данных приведено в самом блокноте. Скрипт использует экселевскую табличку (которую делал Войтенко) с исходным местоположением поездов, локомотивов и бригад, и генерирует ряд csv-файлов и jason-FullPlannerPlugin.log с нужными входными данными.
3. С ним надо обращаться осторожно: все-таки создание новых данных - штука достаточно тонкая, может сломаться в любом месте. Так что надо следить за ошибками при выполнении скрипта.

## Составление отчетов для УТХ

1. Это блокнот `uth_report.ipynb`. Для запуска создан батник `uth_report.bat`.
2. Для корректной работы надо положить файл с логом планировщика в папку `input`, в папке `resources/others` должен лежать файл `Бригады_УТХ*.xlsx` - это выгрузка УТХ-бригад на нужную дату из АРМа Технолога. Также нужен файл `Операции*.txt` - там должны быть указаны операции с УТХ-бригадами (этот файл по умолчанию не используется, но нужен, чтобы скрипт не падал). **TODO: переписать скрипт, исключить необходимость этого файла.**
3. Алгоритм работы такой:
  - выгружаем УТХ-бригады из АРМа Технолога, копируем экселевский файл в `resources/others`;
  - разархивируем лог планировщика в `input`.
  - запускаем `uth_report.bat`. 
4. В результате в папке `report` будет создан html-отчет `uth_report*.html` и соответствующий zip-файл с таким же названием.

## Разные вспомогательные скрипты

### Расчет оптимальных маршрутов

Блокнот `Calc routes.ipynb`. Происходит создание графа сети (нужна библиотека `networkx`), далее из файла `input/mandatory/route_weights.csv` подгружаются исходные веса ребер (участков планирования). Веса не связаны с длиной участка, они нужны для прокладки маршрутов. Далее в скрипте происходит подбор оптимальных весов: 
- вес двухпутных электровозных участков принимается за 1;
- тепловозным и однопутным участкам дается добавка в весе;
- "заградительные" веса (веса для участков, по которым надо ездить только в крайнем случае) берутся из `route_weights.csv`;
- есть набор тестов: несколько пар начальных и конечных станций, между которыми известно, как должен проходить маршрут;
- происходит перебор различных тепловозных и однопутных добавок, для каждой добавки алгоритмом Дейкстры в графе ищется кратчайший маршрут, считается количество пройденных тестов.
- в конце составляется heatmap для разных значений добавок, на которой показывается сколько тестов пройдено. Далее надо выбрать добавки, для которых проходят все тесты, рассчитать и записать веса ребер с этими добавками, составить полный список оптимальных маршрутов между всеми вершинами графа (есть функция в networkx) и записать все маршруты в файл.

### Объемное планирование

Блокнот `Daily Planning.ipynb`. Подсчитывает цифры для таблиц по объемному планированию по Иркутску. Был написан для единичных проверок, в последнее время не использовался, поэтому не могу оценить полезность и актуальность. Возможны ошибки.

### Показатели планирования

Блокнот `metrics_report.ipynb`. Блокнот для проверки расчета показателей планирования: средний вес поездов, производительность локомотивов, полезный пробег локомотивов. Также использовался для анализа причин низких показателей. Давно не использовался, надо проверить и актуализировать.

## Черновик с идеями

Блокнот `specs_draft.ipynb`. Там перечислены темы по доработкам алгоритма планирования, над которыми я думал в последнее время. Некоторые уже реализованы, некоторые - в процессе, до некоторых еще не добрались. По каждой теме сделан небольшой анализ, приведены причины доработок и примерный алгоритм реализации. Предлагаю внимательно его изучить и, возможно, добавить реализацию каких-нибудь идей в план работ.